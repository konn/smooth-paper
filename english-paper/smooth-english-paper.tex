\documentclass[%
  sigconf,authorversion,screen]{acmart}
\usepackage{amsmath}
\input{preamble}

\begin{document}

\title[Automatic Differentiation With Higher Infinitesimals]{Automatic Differentiation With Higher Infinitesimals, or Computational Smooth Infinitesimal Analysis in Weil Algebra}

\author{Hiromi ISHII}
\email{h-ishii@math.tsukuba.ac.jp}
\affiliation{%
  \institution{DeepFlow, Inc.}
  \streetaddress{3-16-40}
  \city{Fujimi-shi Tsuruse nishi}
  \state{Saitama prefecture}
  \country{Japan}
  \postcode{354-0026}
}

\renewcommand{\shortauthors}{Hiromi ISHII}

\begin{abstract}
  \frenchspacing
  We propose an algorithm to compute the $C^\infty$-ring structure of arbitrary Weil algebra, enabling us to do some analysis with \emph{higher inifinitesimals} numerically and symbolically.
  To that end, we first give a brief description of the (forward-mode) \emph{automatic differentiation} (AD) in terms of \emph{$C^\infty$-rings}.
  The notion of $C^\infty$-ring is introduced by Lawvere~\cite{lawvere1979categorical}, and used as the fundamental building block of \emph{smooth infinitesimal analysis} and \emph{synthetic differential geometry}~\cite{Moerdijk:1991aa}.
  We argue that interpreting AD in terms of $C^\infty$-ring, more precisely Weil algebras, gives us a unifying theoretical framework and modular ways to express multivariate partial derivatives modularly.
\end{abstract}

\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010147.10010148.10010149.10010154</concept_id>
        <concept_desc>Computing methodologies~Hybrid symbolic-numeric methods</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10010147.10010148.10010149.10010150</concept_id>
        <concept_desc>Computing methodologies~Algebraic algorithms</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10010147.10010148.10010149.10010152</concept_id>
        <concept_desc>Computing methodologies~Symbolic calculus algorithms</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10002950.10003714.10003732.10003734</concept_id>
        <concept_desc>Mathematics of computing~Differential calculus</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Hybrid symbolic-numeric methods}
\ccsdesc[500]{Computing methodologies~Algebraic algorithms}
\ccsdesc[500]{Computing methodologies~Symbolic calculus algorithms}
\ccsdesc[500]{Mathematics of computing~Differential calculus}
  
\keywords{automatic differentiation, %
  smooth infinitesimal analysis, %
  Weil algebras,%
  smooth algebras, $C^\infty$-rings, %
  symbolic-numeric algorihtms,
  symbolic differentiation, %
  Gr\"{o}bner basis, zero-dimensional ideals}

\maketitle

\section{Introduction}\label{sec:intro}
\sloppy
\emph{Automatic Differentiation} (or, \emph{AD} for short) is known as the method to calculate derivatives of (piecewise) smooth functions accurately and efficiently\fxnote{More elaboration needed}.

This paper is organised as follows.
In \Cref{sec:prel}, we will briefly review the basic concepts and facts on $C^\infty$-rings and Weil algebras.
Subsequently, we will give some exposition of the connection between forward-mode automatic differentiation and Weil algebras in \Cref{sec:ad-and-weils}.
There, we will see how the notion of Weil algebra can be exploited to treat higher-order partial ADs in a unified and general setting.
Then in \Cref{sec:alg}, we will give algorithms to compute $C^\infty$-ring structure of arbitrary Weil algebra, enabling us \emph{automatic differentiation with higher infinitesimals}, or \emph{computational smooth infinitesimal analysis}.
We give some small examples in \Cref{sec:examples}, using our proof-of-concept implementation~\cite{Ishii:2020aa} in Haskell.
Finally, we discuss related and possible future works and conclude in \Cref{sec:concl}.

\section{Preliminaries}\label{sec:prel}
In this section, we will briefly review classical definitions and facts on Weil algebras and $C^\infty$-rings without proofs, which will be used in \Cref{sec:alg}.
For theoretical detail, we refer readers to Moerdijk--Reyes~\cite[Chapters I and II]{Moerdijk:1991aa} or Joyce~\cite{joyce2016algebraic}.

\begin{definition}[Lawvere~\cite{lawvere1979categorical}]
  A \emph{$C^\infty$}-algebra $A$ is a product-preserving functor from the category $\CartSp$ of finite-dimensional Euclidean spaces and smooth maps to the category $\Sets$ of sets.

  We identify $A$ with a $A(\R)$ and $A^n$ with $A(\R^n)$.
\end{definition}

Intuitively, $C^\infty$-ring $A$ is an $\R$-algebra $A$ augmented with $m$-ary operations $A(f): A^m \to A$ respecting composition and product for all smooth map $f: \R^m \to \R$.

One typical example of $C^\infty$-ring is a formal power series ring:

\begin{theorem}[Lawvere]\label{thm:series-is-smooth}
  A ring $\R\llbracket X_1, \dots, X_n\rrbracket$ of formal power series with finite variables has the $C^\infty$-ring structure via Taylor expansion at $0$.
  In particular, lifting of a smooth map $f: \R^m \to \R$ is given by:
  \[
    \Rseries(f)(g_1, \dots, g_m) = \sum_{\alpha \in \N^n} \frac{\X^\alpha}{\alpha!} D^\alpha(f \circ \braket{g_1, \dots, g_n})(\boldsymbol{0}),
  \]
  where $\alpha! = \alpha_1 ! \dots \alpha_n !$ is the multi-index factorial and $D^\alpha$ is the partial differential operator to degree $\alpha$.
\end{theorem}

$C^\infty$-rings of our central interest in this paper is \emph{Weil algebras}, and has deep connection with $\Rseries$:

\begin{definition}[Weil algebra]
  A \emph{Weil algebra} $W$ is an algebra of form $W = \R[X_1, \dots, X_n]/I$ for some ideal $I \subseteq \R[\X]$ such that $\braket{X_1, \dots, X_n}^k \subseteq I$ for some $k \in \N$.
\end{definition}
It follows that Weil algebra $W$ is finite-dimensional as a $R$-linear space and hence $I$ is a \emph{zero-dimensional} ideal.
Weil algebra $W$ can be regarded as a real line $\R$ augmented with nilpotent infinitesimals $d_i = {[X_i]}_I$.
In what follows, we identify an element $\boldsymbol{u} \in W$ of $k$-dimensional Weil algebra $W$ with a $k$-vector $\boldsymbol{u} = (u_1, \dots, u_k) \in \R^k$ of reals.

Although it is not so clear from the definition, Weil algebras have the canonical $C^\infty$-structure.
First note that, if $I$ is zero-dimensional, we have $\R[\X]/I \simeq \R\llbracket \X \rrbracket /I$.
Hence, in particular, Weil algebra $W$ can also be regarded as a quotient ring of formal power series by zero-dimensional ideal.
Thus, together with \Cref{thm:series-is-smooth}, the following lemma shows that any Weil algebra $W$ has the canonical $C^\infty$-ring structure:

\begin{lemma}
  For any $C^\infty$-ring $A$ and a ring-theoretical ideal $I \subseteq A$, the quotient ring $A/I$ again has the canonical $C^\infty$-ring structure.
  In particular, the $C^\infty$-structure of Weil algebra $W$ is given just by post-composition of a quotient mapping to that of $\Rseries$.
\end{lemma}

\section{Connection between Automatic Differentiation and Weil Algebras}
\label{sec:ad-and-weils}

\begin{definition}
  The \emph{dual number ring} is a Weil algebra $\R[X]/(X^2)$.
  We often write $d = {(X)}_I \in \R[d]$ and $\R[d] \coloneq \R[X]/X^2$.

  We use analogous notation for multivariate versions:
  
  \[
    \R[d_1, \dots, d_k] \coloneq \R[\X]/(X_1^2, \dots, X_k^2)
    \simeq \underbrace{\R[d] \otimes_\R \dots \otimes_\R \R[d]}_{k\text{-copies}}
  \]
\end{definition}

By an easy induction, we can show the following:
\begin{theorem}\label{thm:univ-partial-duals}
  For any $f: \R^n \smoothto \R$ and $\boldsymbol{x} \in \R^n$, we have:
  \[
    \R[d_1, \dots, d_k](f)(x + d_1 + \cdots d_n) 
    = \sum_{0 \leq i \leq n} f^{(i)}(x)\sigma^i_n(\vec{d}),
  \]
  where, $\sigma^i_k(x_1, \dots, x_k)$ denotes the $k$-variate elementary symmetric polynomial of degree $i$.
\end{theorem}

It immediately extends to the multivariate case.

\begin{theorem}\label{thm:multi-partial-duals}
  Let
  \[
    W \coloneq \R[d_{1,1}, \dots, d_{1,k_1}] \otimes_\R \dots \otimes_\R \R[d_{n,1}, \dots, d_{n,k_n}].
  \]
  For any $f: \R^n \smoothto \R$ and $\boldsymbol{x} \in \R^n$, we have:
  \begin{align*}
    &W(f)\left(x + \sum_{j \leq n}\sum_{i \leq k_j} d_{j,i}\right) \\
    = &\sum_{\alpha \leq (k_1,\dots,k_n)} \mathop{D}\nolimits^\alpha f(\boldsymbol{x})
    \sigma^{\alpha_1}_{k_1}(\vec{d}_1) 
    \cdots
    \sigma^{\alpha_n}_{k_n}(\vec{d}_n).
  \end{align*}
  In particular, for $\alpha \leq (k_1, \dots, k_n)$, a partial coefficient $D^\alpha(f)(\boldsymbol{x})$ is given by a coefficient of $d_{1,1}^{\alpha_1} d_{2,1}^{\alpha_2} \cdots d_{n,1}^{\alpha_2}$ in $W(f)(\boldsymbol{x})$.
\end{theorem}
This illustrates how we can derive higher-order AD from the first-order forward-mode AD.
If we continue this ad infinitum and lazily, we can reach the same method as so-called Tower AD (see~\cite{Pearlmutter:2007aa,Kmett:2010aa} for detail and implementation).

\begin{theorem}[{See~\cite[4.19 Corollary]{Moerdijk:1991aa}}]
  \label{thm:quot-tensor}
  For ideals $I \subseteq \R\llbracket{}X_1, \dots, X_n\rrbracket$ and $J \subseteq \R\llbracket{}Y_1, \dots, Y_m\rrbracket$, we have:
  \[
    \Rseries/I \otimes_\R \R\llbracket{}\boldsymbol{Y}\rrbracket/J \simeq
    \R\llbracket{}\X, \boldsymbol{Y}\rrbracket/(I, J),
  \]
  where $\otimes_\R$ is a tensor product of $C^\infty$-rings.
\end{theorem}


\section{Algorithms}\label{sec:alg}
In this section, we will present the main results of this paper: concrete algorithms to compute $C^\infty$-structure of arbitrary Weil algebra and their Tensor products.

\subsection{Computing $C^\infty$-structure of Weil algebra}
\label{sec:general-weil-algs}
Let's start with the algorithm $C^\infty$-structure of a general Weil algebra.
Roughly speaking, the algorithm can be divided into threefold:

\begin{enumerate}
  \item A procedure deciding Weil-ness of an ideal and returning data required to compute $C^\infty$-structure (\textsc{WeilTest}, \Cref{alg:weil-test}),
  \item A procedure to compute the lifting  $W(f): W^m \to W$ to Weil albgebra $W$ from $\Rseries(f)$ (\textsc{LiftWeil}, \Cref{alg:smooth-weil}), and
  \item A procedure to lift smooth map $f: \R^m \to \R$ to the $n$-variate formal power series ring $\Rseries$.\label{step:lift-series}
\end{enumerate}

As we shall see later in \Cref{sec:power-series-lifting}, step~\ref{step:lift-series} requires some additional care.
We can calculate the entire $C^\infty$-structure of $\Rseries$ somehow; but, since we don't need the full $C^\infty$-structure of $\Rseries$, we can employ the following restricted and more efficient variant of lifting function:

\begin{enumerate}[label=$(3)'$]
  \item A procedure to lift smooth map $f: \R^m \to R$ to the $n$-variate formal power series ring $\Rseries$, with arguments restricted to \emph{polynomials}: $\Rseries(f) \upharpoonright \R[\X]^m : \R[\X]^m \to \Rseries$
  (\textsc{LiftSeriesPoly}, \Cref{alg:lift-poly-series}).
\end{enumerate}

We start with Weil-ness testing.
First, we define the basic data needed to compute $C^\infty$-structure of Weil algebras:

\begin{definition}[Weil settings]
  The \emph{Weil setting} of a Weil algebra $W$ consists of the following data:
  \begin{enumerate}[ref=(\arabic*)]
    \item Monomial basis $\set{\boldsymbol{b}_1, \dots, \boldsymbol{b}_\ell}$ of $W$,
    \item $M$, the multiplication table of $W$ in terms of the basis,
    \item $(k_1, \dots, k_n) \in \mathbb{N}^n$ such that $k_i$ is the maximum satisfying $X_i^{k_i} \notin I$ for each $i$, and
    \item $\NonVan_W$, a table of representations of non-vanishing monomials in $W$;
    i.e.\ for any $\alpha = (\alpha_1, \dots, \alpha_n) \in \N^n$, if $\alpha_i \leq k_i$ for all $i$, then $\NonVan_W(\X^\alpha) = (c_1, \dots, c_n) \in \R^k$ satisfies $[\X^\alpha]_I = \sum_i c_i \boldsymbol{b}_i$.\label{item:nonvan}
  \end{enumerate}
\end{definition}

A basis and multiplication table allows us to calculate ordinary $\R$-algebra structure of Weil algebra $W$.
The latter two data, $\vec{k}$ and $\NonVan_W$, is essential to compute $C^\infty$-structure of $W$.
In theory, \ref{item:nonvan} is unnecessary if one stores a Gr\"{o}bner basis of $I$;
but since normal form calculation modulo $G$ can take much time in some case, we don't store $G$ itself and use the precalculated data $\NonVan$.
It might be desirable to calculate $\NonVan_W$ as lazily as possible.
Since it involves Gr\"{o}bner basis computation it is more desirable to delay the computation as later as possible and do in an on-demand manner.

We start with Weil-ness testing and returns Weil settings if it is:

\begin{algorithm}[\textsc{WeilTest}]\label{alg:weil-test}
  \hspace{1em}\vspace{-.25em}
  \begin{description}
    \item[Input] An ideal $I \subseteq \mathbb{R}[X_1, \dots, X_n]$
    \item[Output] Returns the Weil settings of $W = \mathbb{R}[\boldsymbol{X}]/I$ if it is a Weil algebra; otherwise \verb|No|.
    \item[Procedure] \textup{\textsc{WeilTest}}
  \end{description}

  \begin{alg}
G <- calcGroebnerBasis(I)
If @$I$@ is not zero-dimensional
  Return No
@$\set{\boldsymbol{b}_1, \dots, \boldsymbol{b}_\ell}$@ <- Monomial basis of @$I$@
@$M$@ <- the Multiplication table of @$W$@
For i in 1..n@\label{line:weil-test:radical-start}@
  @$p_i$@ <- the monic generator of @$I \cap \R[X_i]$@
  Return No If @$p_i$@ is not a monomial
  @$k_i$@ <- @$\deg(p_i) - 1$@@\label{line:weil-test:radical-end}@
@$\NonVan_W$@ <- {}
For @$\alpha$@ in @$\Set{\alpha \in \N^n | \alpha_i \leq k_i \; \forall i \leq \ell}$@
  @$c_1 \boldsymbol{b}_1 + \cdots + c_\ell \boldsymbol{b}_\ell$@ <- @$\rem{\X^\alpha}{G}$@
  @$\NonVan_W(\X^\alpha)$@ <- (@$c_1, \dots, c_\ell$@)
Return (@$\vec{\boldsymbol{b}}, M, \vec{k}, \NonVan_W$@)
\end{alg}
\end{algorithm}

\begin{theorem}
  \Cref{alg:weil-test} terminates and returns expected values.
\end{theorem}
\begin{proof}
  Algorithms to decide the zero-dimensionality and calculate their multiplication table is well-known (for detail we refer readers to Cox--Little--O'Shea~\cite[Chapter 2]{CLO:2005}).
  So the only non-trivial part is nilpotence detection (\Crefrange{line:weil-test:radical-start}{line:weil-test:radical-end}).
  But, again, this is just a variation of radical calculation algorithm for zero-dimensional ideals.
  Indeed, since each $\R[X_i]$ is a PID, we have $X_i^k \in I \cap R[X_i]$ iff $p_i \divs X_i^k$, hence $p_i$ must be a monomial iff $X_i$ is nilpotent in $W$.
\end{proof}
Now that we have information of a basis and multiplication table, we can calculate ordinary algebraic operations and take tensor products of Weil algebras just by the standard means.

And, with upper bounds $\vec k$ of powers and representations $\NonVan_W$ of non-vanishing monomials, we can now compute the $C^\infty$-structure of arbitrary Weil algebra, when given a lifting of smooth mapping $f$ to $\Rseries$:

\begin{algorithm}[\textsc{LiftWeil}]\label{alg:smooth-weil}
  \hfill\vspace{-.25em}
  \begin{description}
    \item[Input]
      $I \subseteq \R[\X]$, an ideal where $W = \R[\X]/I$ is a Weil algebra,
      $\R \llbracket\X\rrbracket(f): \Rseries^m \to \Rseries$, a lifting of a smooth map $f: \R^m \to \R$ to $\Rseries$, and $\vec{\boldsymbol{u}} = (\boldsymbol{u}_1, \dots, \boldsymbol{u}_m) \in W^m$,.
    \item[Output] $\boldsymbol{v} = W(f)(\vec{\boldsymbol u}) \in W$, the value of $f$ at $\vec{\boldsymbol{u}}$ given by $C^\infty$-structure.
    \item[Procedure] \textup{\textsc{LiftWeil}}
  \end{description}
\begin{alg}
(@$\vec{\boldsymbol{b}}$@, M, @$\vec{k}$@, @$\NonVan_W$@) <- WeilTest(I)
g_i <- @$(\boldsymbol{b}_1, \dots, \boldsymbol{b}_k) \cdot \boldsymbol{u}_i \in \R[\X]$@ for i <= m
h = @$\sum_\alpha c_\alpha \X^\alpha$@ <- @$\Rseries(f)(\vec{g})$@
@$\boldsymbol v$@ <- 0
For alpha with @$\alpha_i \leq k_i\, \forall i$@
  @$\boldsymbol{v}$@ <- @$\boldsymbol v$@ + @$c_\alpha \NonVan_W(\X^\alpha)$@
Return @$\boldsymbol{v}$@
\end{alg}
\end{algorithm}

The termination and validity of \Cref{alg:smooth-weil} are clear.

\subsubsection{Computing $C^\infty$-structure of $\Rseries$}\label{sec:power-series-lifting}
So it remains to compute $C^\infty$-structure of $\Rseries$.
Thanks to \Cref{alg:smooth-weil}, we know the precise definition of lifting to $\Rseries$:
\[
  \Rseries(f)(g_1, \dots, g_m) = \sum_{\alpha \in \N^n} \frac{\X^\alpha}{\alpha!} D^\alpha(f \circ \braket{g_1, \dots, g_n})(\boldsymbol{0}),
\]
One might think it straightforward to implement this with AD techniques, such as Lazy multivariate Tower AD~\cite{Pearlmutter:2007aa} or Sparse Tower mode\footnote{For an implementation, see, for example, \texttt{Numeric.AD.Internal.Sparse} module of \texttt{ad}~\cite{Kmett:2010aa}.}; but it is much harder than expected.

One difficulty here is that each term $g_i$ is \emph{not} a smooth function, but \emph{formal power series}.
This means there might not be a corresponding smooth function to each $g_i$ and hence AD technique is unapplicable in general.
Still, one could overcome this situation realising that what we need to compute each coefficient is just the value at $\boldsymbol{0}$, i.e.\ the constant term of each $D^\alpha(f\circ\braket{\vec{g}})$.
Hence, it is possible to calculate $D^\alpha(f\circ\braket{\vec{g}})$ for each $\alpha$ by cutting each $\vec{g}$ off to a polynomial of degree up to $\alpha$, regarding them as a smooth (polynomial) function, and then apply ordinary AD technique to compute them.
Still, we need to apply AD to \emph{distinct} functions $f \circ \braket{g_1 \upharpoonright \alpha, \dots, g_n \upharpoonright \alpha}$ for each $\alpha$.
This means we cannot apply Tower-like AD all at once, meaning we can't make use of caching virtue of such methods, resulting in a less efficient algorithm than expected.

Another possible solution to calculate the entire $C^\infty$-structure of $\Rseries$ is to employ a purely symbolic algorithm to calculate an entire power series.
On the other hand, symbolic computation along this line could be quite expensive without any heuristics.
We include an example of such symbolic implementation in Haskell in the Appendix (\Cref{sec:appendix}).

Fortunately enough, we don't need the entire information of power series when implementing $C^\infty$-structure of Weil algebra.
Carefully analysing the use of power series in \Cref{alg:smooth-weil}, we can notice that all arguement power series $g_1, \dots, g_m$ to lifting function $\Rseries(f)(g_1, \dots, g_m)$ are indeed of finite degree.
Assuming an algorithm \textsc{TowerAD} to compute a coefficient table of partial derivatives of a given smooth function, one can implement the lifting function restricted to polynomial inputs as follows:

\begin{algorithm}[\textsc{LiftSeriesPoly}]\label{alg:lift-poly-series}
\hfill\vspace{-.25em}
\begin{description}
  \item[Input]
    $f: \R^m \smoothto \R$, a smooth function which admits Lazy Tower AD,
    $g_1, \dots, g_n \in \R[X_1, \dots, X_n]$, polynomials.
  \item[Output] $\Rseries(f)(g_1, \dots, g_m): \N^n \to \R$, $f$ lifted to the power series expressed as a function from monomials to coefficient.
  \item[Procedure] \textup{\textsc{LiftSeriesPoly}}
\end{description}
\begin{alg}
@$\hat{g}_i$@ <- a function represented by @$g_i$@
@$\hat{f}$@ <- @$f \circ \braket{\hat{g}_1, \dots, \hat{g}_m}$@
T <- TowerAD(@$\hat f$@)
Return \ (@$\alpha \in \N^n$@) -> @$\frac{T(m)}{\alpha!}$@
\end{alg}
\end{algorithm}

\subsection{Tensor product of Weil algebras}
\label{sec:tensor-algorithm}
As indicated by \Cref{thm:quot-tensor}, tensor products of Weil algebras can be useful to compute multivariate AD.
Here, we give a simple procedure to compute Weil settings of the tensor product of given two algebras.

\begin{algorithm}[WeilTensor]\label{alg:weil-tensor}
\hfill\vspace{-.25em}
\begin{description}
  \item[Input] Weil settings of two Weil algebras $W_1, W_2$,
  with $\set{\boldsymbol{b}_1^i, \dots, \boldsymbol{b}_{\ell_i}^i}$ a basis,
  $(k^i_1, \dots, k^i_{n_i})$ a upper bounds and $M_i$ a multiprication table for each $W_i$.
  \item[Output] Weil settings of $W_1 \otimes_\R W_2$.
  \item[Procedure] {\upshape \textsc{WeilTensor}}
\end{description}
\begin{alg}
(@$\boldsymbol{b}_1, \dots, \boldsymbol{b}_{\ell_1 \ell_2}$@) <- Convol(@$\vec{\boldsymbol{b}}^1, \vec{\boldsymbol{b}}^2$@)
M <- {}
For ({@$\boldsymbol{b}^1_L, \boldsymbol{b}^1_R$@}, @$(c_1,\dots,c_{\ell_1})$@) in @$M_1$@
  For ({@$\boldsymbol{b}^2_L, \boldsymbol{b}^2_R$@}, @$(d_1,\dots,d_{\ell_1})$@) in @$M_2$@
    M({@$\boldsymbol{b}^1_L \boldsymbol{b}^2_L$@, @$\boldsymbol{b}^1_R \boldsymbol{b}^2_R$@}) <- Convol(@$\vec{c}$@, @$\vec{d}$@)
@$\NonVan_{W_1 \otimes W_2}$@ <- {}
For (@$\X^\alpha$@, @$(c_1, \dots, c_{\ell_1})$@) in @$\NonVan_{W_1}$@
  For (@$\Y^\beta$@, @$(d_1,\dots,d_{\ell_2})$@) in @$\NonVan_{W_2}$@
    @$\NonVan_{W_1 \otimes W_2}(\X^\alpha\Y^\beta)$@ <- Convol(@$\vec{c}$@, @$\vec{d}$@)
Return @$(\boldsymbol{b}, M, (\vec{k}^1, \vec{k}^2), \NonVan_{W_1 \otimes W_2})$@
\end{alg}

Here, {\upshape \textsc{Convol}} is a convolution of two sequences:
\begin{description}
  \item[Precedure] $\mathop{\text{\upshape\scshape Convol}}((c_1, \dots, c_{\ell_1}), (d_1, \dots, d_{\ell_2}))$
\end{description}
\begin{alg}
For i in 1..(@$\ell_1 \times \ell_2$@)
  j <- @$\lfloor \frac{i}{\ell_2} \rfloor$@; k <- @$i \mod{\ell_2}$@
  @$a_i$@ <- @$c_j d_k$@
Return (@$a_1, \dots, a_{\ell_1 \ell_2}$@)
\end{alg}
\end{algorithm}

The validity is a routine work.

\section{Examples}\label{sec:examples}
We have implemented the algorithms introduced in the previous section on top of the \texttt{computational-algebra}~\cite{ISHII:2018ek,computational-algebra} package, a computer algebra system implemented as an Embedded Domain Specific Language in Haskell.
The code is available on GitHub~\cite{Ishii:2020aa}.

\section{Conclusion}\label{sec:concl}

\begin{acks}
The author is grateful to Prof.\ Akira Terui, for encouraging  to write this paper.

This work was supported by the Research Institute for Mathematical Sciences,
an International Joint Usage/Research Center located in Kyoto University.
\end{acks}

\section{Appendix: Symbolic computation of smooth structure }\label{sec:appendix}
In \Cref{sec:power-series-lifting}, we just make use of such lifting function with all the inputs are mere polynomials, but with some symbolic computation, we can compute unrestricted $C^\infty$-structure of $\Rseries$ in theory.
Here, we include a referential implementation for Smooth lifting function for general formal power series rings (\texttt{liftSeries}) for completeness.

Basic idea is to use dedicated an abstract syntax tree representing a $k$-ary function composed with $n$-ary series and their partial derivatives.
For brevity, we include a raw source code of their implementation in Haskell.
The same implementation can also be found in our implementation on GitHub~\cite{Ishii:2020aa}.

\begin{code}
newtype PowerSeries n a 
  = Powers (UVec n Natural -> a)
  deriving (Functor)

liftSeries :: Floating a =>
  (forall x. Floating x => Vec k x -> x)
  -> Vec k (PowerSeries n a)
  -> PowerSeries n a
liftSeries f vs = Powers $ \alpha ->
  evalMTree
  ( foldr
    ($)
    (DiffFun $ replicate' 0)
    (diffMTree <$> 
      ifoldMap (flip replicate) alpha
    )
  )
  f
  vs
  / (alpha !)

data MTree m n a
  = Mul (MTree m n a) (MTree m n a)
  | Add (MTree m n a) (MTree m n a)
  | DiffArg (Vec m Natural) (Ordinal n)
  | DiffFun (Vec n Natural)
  | K a
  deriving (Eq, Ord)

evalMTree ::
  ( KnownNat n, KnownNat m
  , Floating a, Eq a
  ) => MTree m n a
    -> (forall x. Floating x 
        => Vec n x -> x)
    -> Vec n (PowerSeries m a)
    -> a
evalMTree (Mul l r) f vs = 
    evalMTree l f vs 
  * evalMTree r f vs
evalMTree (Add l r) f vs =
    evalMTree l f vs 
  + evalMTree r f vs
evalMTree (DiffArg pow i) f vs =
  constPTerm 
    (formalNDiff pow (vs %!! i))
evalMTree (DiffFun pows) f vs =
  head 
    (multDiff pows (singleton . f)
      (map constPTerm vs))
evalMTree (K a) _ _ = a
\end{code}

\bibliographystyle{ACM-Reference-Format}
\bibliography{../references}

\end{document}
\endinput
