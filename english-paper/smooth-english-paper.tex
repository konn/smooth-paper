\documentclass[%
  sigconf,authorversion,screen]{acmart}
\usepackage{amsmath}
\input{preamble}

\begin{document}

\title[Automatic Differentiation With Higher Infinitesimals]{Automatic Differentiation With Higher Infinitesimals, or Computational Smooth Infinitesimal Analysis in Weil Algebra}

\author{Hiromi ISHII}
\email{h-ishii@math.tsukuba.ac.jp}
\affiliation{%
  \institution{DeepFlow, Inc.}
  \streetaddress{3-16-40}
  \city{Fujimi-shi Tsuruse nishi}
  \state{Saitama prefecture}
  \country{Japan}
  \postcode{354-0026}
}

\renewcommand{\shortauthors}{Hiromi ISHII}

\begin{abstract}
  \frenchspacing
  We propose an algorithm to compute the $C^\infty$-ring structure of arbitrary Weil algebra, enabling us to do some analysis with \emph{higher inifinitesimals} numerically and symbolically.
  To that end, we first give a brief description of the (forward-mode) \emph{automatic differentiation} (AD) in terms of \emph{$C^\infty$-rings}.
  The notion of $C^\infty$-ring is introduced by Lawvere~\cite{lawvere1979categorical}, and used as the fundamental building block of \emph{smooth infinitesimal analysis} and \emph{synthetic differential geometry}~\cite{Moerdijk:1991aa}.
  We argue that interpreting AD in terms of $C^\infty$-rings, more precisely Weil algebras, gives us a unifying theoretical framework and modular ways to express multivariate partial derivatives modularly.
\end{abstract}

\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010147.10010148.10010149.10010154</concept_id>
        <concept_desc>Computing methodologies~Hybrid symbolic-numeric methods</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10010147.10010148.10010149.10010150</concept_id>
        <concept_desc>Computing methodologies~Algebraic algorithms</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10010147.10010148.10010149.10010152</concept_id>
        <concept_desc>Computing methodologies~Symbolic calculus algorithms</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10002950.10003714.10003732.10003734</concept_id>
        <concept_desc>Mathematics of computing~Differential calculus</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Hybrid symbolic-numeric methods}
\ccsdesc[500]{Computing methodologies~Algebraic algorithms}
\ccsdesc[500]{Computing methodologies~Symbolic calculus algorithms}
\ccsdesc[500]{Mathematics of computing~Differential calculus}
  
\keywords{automatic differentiation, %
  smooth infinitesimal analysis, %
  Weil algebras,%
  smooth algebras, $C^\infty$-rings, %
  symbolic-numeric algorihtms,
  symbolic differentiation, %
  Gr\"{o}bner basis, zero-dimensional ideals}

\maketitle

\section{Introduction}\label{sec:intro}
\sloppy
\emph{Automatic Differentiation} (or, \emph{AD} for short) is known as the method to calculate derivatives of (piecewise) smooth functions accurately and efficiently.
It has a long history of research, and by the recent rise of needs of differentiable programming in the realm of machine learning, methods of AD attracts some interests again nowadays.

\emph{Smooth Infinitesimal Analysis} (or, \emph{SIA} for short), on the other hand, is an area of mathematics that uses \emph{nilpotent infinitesimals} to build the theory of real analysis intuitionistically.
Its central building blocks are \emph{Weil algebras}, which can be viewed as the real line augmented with nilpotent infinitesimals.
Indeed, SIA is a subarea of \emph{Synthetic Differential Geometry} (SDG) initiated by Lawvere~\cite{lawvere1979categorical}, which studies smooth manifolds topos theoretically, and higher multivariate infinitesimals plays an important role in building theory of, e.g.\ vector fields, differential forms and tangent spaces.
The crucial observation of Lawvere is that manifolds can be classified solely by their smooth function ring $C^\infty(M)$, and both such function rings and Weil algebras are special cases of \emph{$C^\infty$-rings}.

It has been pointed out that AD and SIA have some connection; e.g.\ even Wikipedia article~\cite{Wikipedia:2021aa} mentions the connection between first-order forward-mode AD with the ring $\R[X]/(X^2)$ of dual numbers.
However, a precise theoretical description of this correspondence is not well-communicated and further generalisation of AD in terms of SIA hasn't been discussed enough.

The present paper aims at filling this gap, giving a unified description of AD in terms of $C^\infty$-rings and Weil algebras.
Further, our main contribution is the algorithms to compute $C^\infty$-ring structure of general Weil algebra.
This enables automatic differentiation done in \emph{arbitrary} Weil algebras other than dual numbers, and, together with tensor products, lets us compute higher-order multivariate partial derivatives in a modular and composable manner, packed as Weil algebra.
Such algorithms can also be used to learn and study the theory of SIA and SDG.

This paper is organised as follows.
In \Cref{sec:prel}, we will briefly review the basic concepts and facts on $C^\infty$-rings and Weil algebras.
Subsequently, we will give some exposition of the connection between forward-mode automatic differentiation and Weil algebras in \Cref{sec:ad-and-weils}.
There, we will see how the notion of Weil algebra can be exploited to treat higher-order partial ADs in a unified and general setting.
Then in \Cref{sec:alg}, we will give algorithms to compute $C^\infty$-ring structure of arbitrary Weil algebra, enabling us \emph{automatic differentiation with higher infinitesimals}, or \emph{computational smooth infinitesimal analysis}.
We give some small examples in \Cref{sec:examples}, using our proof-of-concept implementation~\cite{Ishii:2020aa} in Haskell.
Finally, we discuss related and possible future works and conclude in \Cref{sec:concl}.

\section{Preliminaries}\label{sec:prel}
In this section, we will briefly review classical definitions and facts on Weil algebras and $C^\infty$-rings without proofs, which will be used in \Cref{sec:alg}.
For theoretical detail, we refer readers to Moerdijk--Reyes~\cite[Chapters I and II]{Moerdijk:1991aa} or Joyce~\cite{joyce2016algebraic}.

\begin{definition}[Lawvere~\cite{lawvere1979categorical}]
  A \emph{$C^\infty$}-algebra $A$ is a product-preserving functor from the category $\CartSp$ of finite-dimensional Euclidean spaces and smooth maps to the category $\Sets$ of sets.

  We identify $A$ with a $A(\R)$ and $A^n$ with $A(\R^n)$.
\end{definition}

Intuitively, $C^\infty$-ring $A$ is an $\R$-algebra $A$ augmented with $m$-ary operations $A(f): A^m \to A$ respecting composition and product for all smooth map $f: \R^m \to \R$.

One typical example of $C^\infty$-ring is a formal power series ring:

\begin{theorem}[Lawvere]\label{thm:series-is-smooth}
  A ring $\R\llbracket d(1), \dots, X_n\rrbracket$ of formal power series with finite variables has the $C^\infty$-ring structure via Taylor expansion at $0$.
  In particular, lifting of a smooth map $f: \R^m \to \R$ is given by:
  \[
    \Rseries(f)(g_1, \dots, g_m) = \sum_{\alpha \in \N^n} \frac{\X^\alpha}{\alpha!} D^\alpha(f \circ \braket{g_1, \dots, g_n})(\boldsymbol{0}),
  \]
  where $\alpha! = \alpha_1 ! \dots \alpha_n !$ is the multi-index factorial and $D^\alpha$ is the partial differential operator to degree $\alpha$.
\end{theorem}

$C^\infty$-rings of our central interest in this paper is \emph{Weil algebras}, and has deep connection with $\Rseries$:

\begin{definition}[Weil algebra]
  A \emph{Weil algebra} $W$ is an algebra of form $W = \R[d(1), \dots, X_n]/I$ for some ideal $I \subseteq \R[\X]$ such that $\braket{d(1), \dots, X_n}^k \subseteq I$ for some $k \in \N$.
\end{definition}
It follows that Weil algebra $W$ is finite-dimensional as a $R$-linear space and hence $I$ is a \emph{zero-dimensional} ideal.
Weil algebra $W$ can be regarded as a real line $\R$ augmented with nilpotent infinitesimals $d_i = {[X_i]}_I$.
In what follows, we identify an element $\boldsymbol{u} \in W$ of $k$-dimensional Weil algebra $W$ with a $k$-vector $\boldsymbol{u} = (u_1, \dots, u_k) \in \R^k$ of reals.

Although it is not so clear from the definition, Weil algebras have the canonical $C^\infty$-structure.
First note that, if $I$ is zero-dimensional, we have $\R[\X]/I \simeq \R\llbracket \X \rrbracket /I$.
Hence, in particular, Weil algebra $W$ can also be regarded as a quotient ring of formal power series by zero-dimensional ideal.
Thus, together with \Cref{thm:series-is-smooth}, the following lemma shows that any Weil algebra $W$ has the canonical $C^\infty$-ring structure:

\begin{lemma}\label{lem:quot-ring-ideal}
  For any $C^\infty$-ring $A$ and a ring-theoretical ideal $I \subseteq A$, the quotient ring $A/I$ again has the canonical $C^\infty$-ring structure.
  In particular, the $C^\infty$-structure of Weil algebra $W$ is given just by post-composition of a quotient mapping to that of $\Rseries$.
\end{lemma}

\section{Connection between Automatic Differentiation and Weil Algebras}
\label{sec:ad-and-weils}
In this section, based on the basic facts on $C^\infty$-rings and Weil algebras reviewed in \Cref{sec:prel}, we describe the connection of automatic differentiation (AD) and Weil algebra.

\emph{Forward-mode} AD is a technique to compute a value and differential coefficient of given univariate composition of smooth function efficiently.
It can be used implemented by ad-hoc polymorphism (or equivalently, function overloading).
For detailed implementation, we refer readers to Elliott~\cite{Elliott2009-beautiful-differentiation} and Ekmett's \texttt{ad} package~\cite{Kmett:2010aa}.

Briefly speaking, in forward-mode AD, one stores both the value and differential coefficient simultaneously, say in a form $f(x) + f'(x) d$ for $d$ an opaque variable.
Then, when evaluating composite functions, one uses Chain Rule for implementation:
\[
  \frac{\mathrm{d}}{\mathrm{d}x}(g \circ f)(x) = f'(x) g'(f(x))
\]

The following definition of functions on dual numbers illustrate the idea:

\begin{align*}
  (a_1 + b_1 d) + (a_2 + b_2 d) &= (a_1 + a_2) + (b_1 + b_2)d\\
  (a_1 + b_1 d) \times (a_2 + b_2 d) &= a_1 a_2 + (a_1 b_2 + a_2 b_1)d\\
  \cos(a_1 + b_1 d) &= \cos(a_1) - b_1 \sin(a_1) d
\end{align*}

The first two equations for addition and multiplication suggests that operations could be seen extending the algebraic structure of $\R[d] = \R[X]/(X^2)$.
Indeed, as stated in the introduction, first-order forward-mode AD can be identified with the arithmetic on \emph{dual numbers}:
\begin{definition}
  The \emph{dual number ring} is a Weil algebra $\R[X]/(X^2)$.
  We often write $d = {(X)}_I \in \R[d]$ and $\R[d] \coloneq \R[X]/X^2$.

  We use an analogous notation for multivariate versions:
  
  \[
    \R[d_1, \dots, d_k] \coloneq \R[\X]/(X_1^2, \dots, X_k^2)
  \]
\end{definition}

Since the dual number ring $\R[d]$ is a Weil algebra, one can apply \Cref{thm:series-is-smooth} and \Cref{lem:quot-ring-ideal} to compute its $C^\infty$-structure.
Letting $f: \R \smoothto \R$ a univariate smooth function, then we can derive $C^\infty$-lifting $\R[d](f): \R[d] \to \R[d]$ can be calculated as follows:

\begin{alignat*}{3}
  &&&\R\llbracket{}X\rrbracket(f)(a + bX) \\
  &&=\:&f(a) + \frac{\mathrm d}{\mathrm{d} x}(f(a + bx))(0) X + \cdots
  &\quad&(\text{by \Cref{thm:series-is-smooth}})\\
  &&=\:&f(a) + b f'(a) X + \cdots\\
  &&\xrightarrow{X \mapsto d}\:&f(a) + bf'(a) d\\
  &\therefore&& \R[d](f)(a + bd) = f(a) + b f'(a) 
  && (\text{by \Cref{lem:quot-ring-ideal}}) \tag{\ensuremath{\ast}}
  \label{eqn:dual-smooth}
\end{alignat*}

One can notice that the derived $C^\infty$-structure in \eqref{eqn:dual-smooth} is exactly the same as how to implement individual smooth functions for forward-mode AD.
This describes the connection between forward-mode AD and dual numbers: forward-mode AD is just an implementation of $C^\infty$-structure of the dual number ring $\R[d]$.

Let's see how this can be extended to the higher-order case.
The most na√Øve way to compute higher-order derivatives of smooth function is just to successively differentiating it.
This intuition can be expressed just by duplicating the number of basis of dual numbers:
\begin{theorem}\label{thm:univ-partial-duals}
  For any $f: \R \smoothto \R$ and $\boldsymbol{x} \in \R^n$, we have:
  \[
    \R[d_1, \dots, d_k](f)(x + d_1 + \cdots d_n) 
    = \sum_{0 \leq i \leq n} f^{(i)}(x)\sigma^i_n(\vec{d}),
  \]
  where, $\sigma^i_k(x_1, \dots, x_k)$ denotes the $k$-variate elementary symmetric polynomial of degree $i$.
\end{theorem}

The above can be proven by an easy induction.
If we continue this ad infinitum and lazily, we can reach the same method as so-called Tower AD (see~\cite{Pearlmutter:2007aa,Kmett:2010aa} for detail and implementation).

However, as one can easily see, terms in $\Rseries/(X_i^2)$ can grow exponentially and it includes duplicated coefficients.
We can get derivatives in more succinct representation with \emph{higher infinitesimal} beyond dual numbers:

\begin{lemma}\label{lem:higher-infinitesimal}
  Let $W = \R[X]/(X^{n + 1})$ and $\varepsilon = {[X]}_{(X^{n+1})}$ for $n \in \N$.
  Given $f: \R \smoothto \R$ and $a \in \R$, we have:
  \[
    W(f)(a + d)
    = \sum_{k \leq n} \frac{f^{(k)}(a)}{k !} X^k.
  \]
\end{lemma}
In this representation, we only have $(n + 1)$-terms and hence it results in succinct and efficient representation of derivatives.

If we duplicate such higher-order infinitesimals as much as one wants, one can likewise compute multivariate higher-order derivatives all at once, up to some multidegree $\beta$:
\begin{lemma}
  Let $I = \left(X_i^{\beta_i + 1}\ \middle|\ i \leq m \right)$, $W = \R[X_1, \dots, X_m]/I$, and $\varepsilon_i = {[X_i]}_I$ for $n_1, \dots, n_m \in \N$ and $\beta = {(\beta_i)}_{i \leq m} \in \N^m$.
  For $f: \R^m \smoothto \R$ and $\boldsymbol{a} = {(a_i)}_{i \leq m} \in \R$, we have:
  \[
    W(f)(a_1 + \varepsilon_1, \dots, a_m + \varepsilon_m) =
      \sum_{\delta_i \leq \beta_i} 
      \frac{D^\delta f}{\delta !}(\boldsymbol{a}) \X^\delta.
  \]
\end{lemma}

So far, we have used Weil algebra of form $\Rseries/I$.
So, do we need to define new ideals whenever one wants to treat multiple variables?
The answer is no; as indicated by the following lemma, we can use algebraic tensor products to compose existing multiple Weil algebras into one:

\begin{lemma}[{See~\cite[4.19 Corollary]{Moerdijk:1991aa}}]
  \label{thm:quot-tensor}
  For ideals $I \subseteq \R\llbracket\X\rrbracket$ and $J \subseteq \R\llbracket{}\Y\rrbracket$, we have:
  \[
    \Rseries/I \otimes_\R \R\llbracket{}\boldsymbol{Y}\rrbracket/J \simeq
    \R\llbracket{}\X, \boldsymbol{Y}\rrbracket/(I, J),
  \]
  where $\otimes_\R$ is a tensor product of $C^\infty$-rings.
\end{lemma}
Thanks to this lemma, we don't have to define $I$ by hand every time, but just can take tensor products to compose them to compute multivariate and higher-order derivatives.
Examples of such calculations will be discussed in \Cref{sec:examples}.

\section{Algorithms}\label{sec:alg}
In this section, we will present the main results of this paper: concrete algorithms to compute $C^\infty$-structure of arbitrary Weil algebra and their Tensor products.
For examples of applications of the algorithm presented here, the reader can skip to the next \cref{sec:examples} to comprehend the actual use case.

\subsection{Computing $C^\infty$-structure of Weil algebra}
\label{sec:general-weil-algs}
Let's start with the algorithm $C^\infty$-structure of a general Weil algebra.
Roughly speaking, the algorithm can be divided into threefold:

\begin{enumerate}
  \item A procedure deciding Weil-ness of an ideal and returning data required to compute $C^\infty$-structure (\textsc{WeilTest}, \Cref{alg:weil-test}),
  \item A procedure to compute the lifting  $W(f): W^m \to W$ to Weil albgebra $W$ from $\Rseries(f)$ (\textsc{LiftWeil}, \Cref{alg:smooth-weil}), and
  \item A procedure to lift smooth map $f: \R^m \to \R$ to the $n$-variate formal power series ring $\Rseries$.\label{step:lift-series}
\end{enumerate}

As we shall see later in \Cref{sec:power-series-lifting}, step~\ref{step:lift-series} requires some additional care.
We can calculate the entire $C^\infty$-structure of $\Rseries$ somehow; but, since we don't need the full $C^\infty$-structure of $\Rseries$, we can employ the following restricted and more efficient variant of lifting function:

\begin{enumerate}[label=$(3)'$]
  \item A procedure to lift smooth map $f: \R^m \to R$ to the $n$-variate formal power series ring $\Rseries$, with arguments restricted to \emph{polynomials}: $\Rseries(f) \upharpoonright \R[\X]^m : \R[\X]^m \to \Rseries$
  (\textsc{LiftSeriesPoly}, \Cref{alg:lift-poly-series}).
\end{enumerate}

We start with Weil-ness testing.
First, we define the basic data needed to compute $C^\infty$-structure of Weil algebras:

\begin{definition}[Weil settings]
  The \emph{Weil setting} of a Weil algebra $W$ consists of the following data:
  \begin{enumerate}[ref=(\arabic*)]
    \item Monomial basis $\set{\boldsymbol{b}_1, \dots, \boldsymbol{b}_\ell}$ of $W$,
    \item $M$, the multiplication table of $W$ in terms of the basis,
    \item $(k_1, \dots, k_n) \in \mathbb{N}^n$ such that $k_i$ is the maximum satisfying $X_i^{k_i} \notin I$ for each $i$, and
    \item $\NonVan_W$, a table of representations of non-vanishing monomials in $W$;
    i.e.\ for any $\alpha = (\alpha_1, \dots, \alpha_n) \in \N^n$, if $\alpha_i \leq k_i$ for all $i$, then $\NonVan_W(\X^\alpha) = (c_1, \dots, c_n) \in \R^k$ satisfies $[\X^\alpha]_I = \sum_i c_i \boldsymbol{b}_i$.\label{item:nonvan}
  \end{enumerate}
\end{definition}

A basis and multiplication table allows us to calculate ordinary $\R$-algebra structure of Weil algebra $W$.
The latter two data, $\vec{k}$ and $\NonVan_W$, is essential to compute $C^\infty$-structure of $W$.
In theory, \ref{item:nonvan} is unnecessary if one stores a Gr\"{o}bner basis of $I$;
but since normal form calculation modulo $G$ can take much time in some case, we don't store $G$ itself and use the precalculated data $\NonVan$.
It might be desirable to calculate $\NonVan_W$ as lazily as possible.
Since it involves Gr\"{o}bner basis computation it is more desirable to delay the computation as later as possible and do in an on-demand manner.

We start with Weil-ness testing and returns Weil settings if it is:

\begin{algorithm}[\textsc{WeilTest}]\label{alg:weil-test}
  \hspace{1em}\vspace{-.25em}
  \begin{description}
    \item[Input] An ideal $I \subseteq \mathbb{R}[d(1), \dots, X_n]$
    \item[Output] Returns the Weil settings of $W = \mathbb{R}[\boldsymbol{X}]/I$ if it is a Weil algebra; otherwise \verb|No|.
    \item[Procedure] \textup{\textsc{WeilTest}}
  \end{description}

  \begin{alg}
G <- calcGroebnerBasis(I)
If @$I$@ is not zero-dimensional
  Return No
@$\set{\boldsymbol{b}_1, \dots, \boldsymbol{b}_\ell}$@ <- Monomial basis of @$I$@
@$M$@ <- the Multiplication table of @$W$@
For i in 1..n@\label{line:weil-test:radical-start}@
  @$p_i$@ <- the monic generator of @$I \cap \R[X_i]$@
  Return No If @$p_i$@ is not a monomial
  @$k_i$@ <- @$\deg(p_i) - 1$@@\label{line:weil-test:radical-end}@
@$\NonVan_W$@ <- {}
For @$\alpha$@ in @$\Set{\alpha \in \N^n | \alpha_i \leq k_i \; \forall i \leq \ell}$@
  @$c_1 \boldsymbol{b}_1 + \cdots + c_\ell \boldsymbol{b}_\ell$@ <- @$\rem{\X^\alpha}{G}$@
  @$\NonVan_W(\X^\alpha)$@ <- (@$c_1, \dots, c_\ell$@)
Return (@$\vec{\boldsymbol{b}}, M, \vec{k}, \NonVan_W$@)
\end{alg}
\end{algorithm}

\begin{theorem}
  \Cref{alg:weil-test} terminates and returns expected values.
\end{theorem}
\begin{proof}
  Algorithms to decide the zero-dimensionality and calculate their multiplication table is well-known (for detail we refer readers to Cox--Little--O'Shea~\cite[Chapter 2]{CLO:2005}).
  So the only non-trivial part is nilpotence detection (\Crefrange{line:weil-test:radical-start}{line:weil-test:radical-end}).
  But, again, this is just a variation of radical calculation algorithm for zero-dimensional ideals.
  Indeed, since each $\R[X_i]$ is a PID, we have $X_i^k \in I \cap R[X_i]$ iff $p_i \divs X_i^k$, hence $p_i$ must be a monomial iff $X_i$ is nilpotent in $W$.
\end{proof}
Now that we have information of a basis and multiplication table, we can calculate ordinary algebraic operations and take tensor products of Weil algebras just by the standard means.

And, with upper bounds $\vec k$ of powers and representations $\NonVan_W$ of non-vanishing monomials, we can now compute the $C^\infty$-structure of arbitrary Weil algebra, when given a lifting of smooth mapping $f$ to $\Rseries$:

\begin{algorithm}[\textsc{LiftWeil}]\label{alg:smooth-weil}
  \hfill\vspace{-.25em}
  \begin{description}
    \item[Input]
      $I \subseteq \R[\X]$, an ideal where $W = \R[\X]/I$ is a Weil algebra,
      $\R \llbracket\X\rrbracket(f): \Rseries^m \to \Rseries$, a lifting of a smooth map $f: \R^m \to \R$ to $\Rseries$, and $\vec{\boldsymbol{u}} = (\boldsymbol{u}_1, \dots, \boldsymbol{u}_m) \in W^m$,.
    \item[Output] $\boldsymbol{v} = W(f)(\vec{\boldsymbol u}) \in W$, the value of $f$ at $\vec{\boldsymbol{u}}$ given by $C^\infty$-structure.
    \item[Procedure] \textup{\textsc{LiftWeil}}
  \end{description}
\begin{alg}
(@$\vec{\boldsymbol{b}}$@, M, @$\vec{k}$@, @$\NonVan_W$@) <- WeilTest(I)
g_i <- @$(\boldsymbol{b}_1, \dots, \boldsymbol{b}_k) \cdot \boldsymbol{u}_i \in \R[\X]$@ for i <= m
h = @$\sum_\alpha c_\alpha \X^\alpha$@ <- @$\Rseries(f)(\vec{g})$@
@$\boldsymbol v$@ <- 0
For alpha with @$\alpha_i \leq k_i\, \forall i$@
  @$\boldsymbol{v}$@ <- @$\boldsymbol v$@ + @$c_\alpha \NonVan_W(\X^\alpha)$@
Return @$\boldsymbol{v}$@
\end{alg}
\end{algorithm}

The termination and validity of \Cref{alg:smooth-weil} are clear.

Now that we can compute the $\R$-algebraic and $C^\infty$-structure of a Weil algebra solely from its Weil setting, one can hard-code pre-calculated Weil settings for known typical Weil algebras, such as the dual number ring or higher infinitesimal rings of form $\R[X]/(X^{n+1})$, to reduce computational overheads.

\subsubsection{Computing $C^\infty$-structure of $\Rseries$}\label{sec:power-series-lifting}
So it remains to compute $C^\infty$-structure of $\Rseries$.
Thanks to \Cref{alg:smooth-weil}, we know the precise definition of lifting to $\Rseries$:
\[
  \Rseries(f)(g_1, \dots, g_m) = \sum_{\alpha \in \N^n} \frac{\X^\alpha}{\alpha!} D^\alpha(f \circ \braket{g_1, \dots, g_n})(\boldsymbol{0}),
\]
One might think it straightforward to implement this with AD techniques, such as Lazy multivariate Tower AD~\cite{Pearlmutter:2007aa} or Sparse Tower mode\footnote{For an implementation, see, for example, \texttt{Numeric.AD.Internal.Sparse} module of \texttt{ad}~\cite{Kmett:2010aa}.}; but it is much harder than expected.

One difficulty here is that each term $g_i$ is \emph{not} a smooth function, but \emph{formal power series}.
This means there might not be a corresponding smooth function to each $g_i$ and hence AD technique is unapplicable in general.
Still, one could overcome this situation realising that what we need to compute each coefficient is just the value at $\boldsymbol{0}$, i.e.\ the constant term of each $D^\alpha(f\circ\braket{\vec{g}})$.
Hence, it is possible to calculate $D^\alpha(f\circ\braket{\vec{g}})$ for each $\alpha$ by cutting each $\vec{g}$ off to a polynomial of degree up to $\alpha$, regarding them as a smooth (polynomial) function, and then apply ordinary AD technique to compute them.
Still, we need to apply AD to \emph{distinct} functions $f \circ \braket{g_1 \upharpoonright \alpha, \dots, g_n \upharpoonright \alpha}$ for each $\alpha$.
This means we cannot apply Tower-like AD all at once, meaning we can't make use of caching virtue of such methods, resulting in a less efficient algorithm than expected.

Another possible solution to calculate the entire $C^\infty$-structure of $\Rseries$ is to employ a purely symbolic algorithm to calculate an entire power series.
On the other hand, symbolic computation along this line could be quite expensive without any heuristics.
For an implementation of symbolic algorithm, see \hask{liftSmoothSeries} function in \texttt{Numeric.Algebra.Smooth.Weil} module of our referential implementation~\cite{Ishii:2020aa}.

Fortunately enough, we don't need the entire information of power series when implementing $C^\infty$-structure of Weil algebra.
Carefully analysing the use of power series in \Cref{alg:smooth-weil}, we can notice that all arguement power series $g_1, \dots, g_m$ to lifting function $\Rseries(f)(g_1, \dots, g_m)$ are indeed of finite degree.
Assuming an algorithm \textsc{TowerAD} to compute a coefficient table of partial derivatives of a given smooth function, one can implement the lifting function restricted to polynomial inputs as follows:

\begin{algorithm}[\textsc{LiftSeriesPoly}]\label{alg:lift-poly-series}
\hfill\vspace{-.25em}
\begin{description}
  \item[Input]
    $f: \R^m \smoothto \R$, a smooth function which admits Lazy Tower AD,
    $g_1, \dots, g_n \in \R[d(1), \dots, X_n]$, polynomials.
  \item[Output] $\Rseries(f)(g_1, \dots, g_m): \N^n \to \R$, $f$ lifted to the power series expressed as a function from monomials to coefficient.
  \item[Procedure] \textup{\textsc{LiftSeriesPoly}}
\end{description}
\begin{alg}
@$\hat{g}_i$@ <- a function represented by @$g_i$@
@$\hat{f}$@ <- @$f \circ \braket{\hat{g}_1, \dots, \hat{g}_m}$@
T <- TowerAD(@$\hat f$@)
Return \ (@$\alpha \in \N^n$@) -> @$\frac{T(m)}{\alpha!}$@
\end{alg}
\end{algorithm}

\subsection{Tensor product of Weil algebras}
\label{sec:tensor-algorithm}
As indicated by \Cref{thm:quot-tensor}, tensor products of Weil algebras enables us to compose multiple Weil algebras into one and use them to compute higher-order multivariate derivatives.
Here, we give a simple procedure to compute Weil settings of the tensor product of given two algebras.

\begin{algorithm}[WeilTensor]\label{alg:weil-tensor}
\hfill\vspace{-.25em}
\begin{description}
  \item[Input] Weil settings of two Weil algebras $W_1, W_2$,
  with $\set{\boldsymbol{b}_1^i, \dots, \boldsymbol{b}_{\ell_i}^i}$ a basis,
  $(k^i_1, \dots, k^i_{n_i})$ a upper bounds and $M_i$ a multiprication table for each $W_i$.
  \item[Output] Weil settings of $W_1 \otimes_\R W_2$.
  \item[Procedure] {\upshape \textsc{WeilTensor}}
\end{description}
\begin{alg}
(@$\boldsymbol{b}_1, \dots, \boldsymbol{b}_{\ell_1 \ell_2}$@) <- Convol(@$\vec{\boldsymbol{b}}^1, \vec{\boldsymbol{b}}^2$@)
M <- {}
For ({@$\boldsymbol{b}^1_L, \boldsymbol{b}^1_R$@}, @$(c_1,\dots,c_{\ell_1})$@) in @$M_1$@
  For ({@$\boldsymbol{b}^2_L, \boldsymbol{b}^2_R$@}, @$(d_1,\dots,d_{\ell_1})$@) in @$M_2$@
    M({@$\boldsymbol{b}^1_L \boldsymbol{b}^2_L$@, @$\boldsymbol{b}^1_R \boldsymbol{b}^2_R$@}) <- Convol(@$\vec{c}$@, @$\vec{d}$@)
@$\NonVan_{W_1 \otimes W_2}$@ <- {}
For (@$\X^\alpha$@, @$(c_1, \dots, c_{\ell_1})$@) in @$\NonVan_{W_1}$@
  For (@$\Y^\beta$@, @$(d_1,\dots,d_{\ell_2})$@) in @$\NonVan_{W_2}$@
    @$\NonVan_{W_1 \otimes W_2}(\X^\alpha\Y^\beta)$@ <- Convol(@$\vec{c}$@, @$\vec{d}$@)
Return @$(\boldsymbol{b}, M, (\vec{k}^1, \vec{k}^2), \NonVan_{W_1 \otimes W_2})$@
\end{alg}

Here, {\upshape \textsc{Convol}} is a convolution of two sequences:
\begin{description}
  \item[Precedure] $\mathop{\text{\upshape\scshape Convol}}((c_1, \dots, c_{\ell_1}), (d_1, \dots, d_{\ell_2}))$
\end{description}
\begin{alg}
For i in 1..(@$\ell_1 \times \ell_2$@)
  j <- @$\lfloor \frac{i}{\ell_2} \rfloor$@; k <- @$i \mod{\ell_2}$@
  @$a_i$@ <- @$c_j d_k$@
Return (@$a_1, \dots, a_{\ell_1 \ell_2}$@)
\end{alg}
\end{algorithm}

The validity proof is routine work.

\section{Examples}\label{sec:examples}
We have implemented the algorithms introduced in the previous section on top of two libraries: \texttt{computational-algebra} package~\cite{ISHII:2018ek,computational-algebra} and \texttt{ad} package~\cite{Kmett:2010aa}.
The code is available on GitHub~\cite{Ishii:2020aa}.

\subsection{Higher-order derivatives via dual numbers and higher infinitesimals}
As indicated by \Cref{thm:univ-partial-duals} and \Cref{lem:higher-infinitesimal},
to compute higher-order derivatives of univariate functions with we can use multiple tensor products of Dual numbers or higher-order infinitesimals.

Let us first compute higher-order derivatives of $\sin$ up to $3$.

First, let's use tensor product of dual numbers:
\begin{code}
d1, d2, d3
  :: Floating a
  => Weil (D1 |*| D1 |*| D1) a
[d1, d2, d3] = map di [0..]
\end{code}

Here, \hask{Weil w a} represents the type of Weil algebra with ideal information given in \hask{w}.
Here, \hask{D1} corresponds to dual number ideal, say $I = (X^2)$, and \hask{|*|} corresponds to the tensor product operator.
Each $d_i$ corresnponds to $i$\textsuperscript{th} infinitesimal.

OK, then let's calculate higher-order differntial coefficients at $x = \frac{\pi}{6}$ up to the third:

\begin{code}
>>> ( sin (pi/6),  cos (pi/6), 
     -sin (pi/6), -cos (pi/6))
( 0.49999999999999994,
  0.8660254037844387,
 -0.49999999999999994,
 -0.8660254037844387)

>>> sin (pi/6 + d0 + d1 + d2)
-0.8660254037844387 d(0) d(1) d(2) 
  - 0.49999999999999994 d(0) d(1) 
  - 0.49999999999999994 d(0) d(2)
  - 0.49999999999999994 d(1) d(2) 
  + 0.8660254037844387 d(0) 
  + 0.8660254037844387 d(1) 
  + 0.8660254037844387 d(2) 
  + 0.49999999999999994
\end{code}

It is easy to see that terms of degree $i$ has coefficients $\sin^{(i)}(\pi/6)$.
Since our implementation is polymorphic, if we apply the same function to the type for symbolic computation, say \hask{Symbolic}, we can reconstruct symbolic differentiation and check that the result is indeed correct symbolically:

\begin{code}
x :: Weil w Symbolic
x = injectCoeff (var "x")

>>> normalise <$> sin (x + d0+d1+d2)
((-1.0) * cos x) d(0) d(1) d(2) 
  + (- (sin x)) d(0) d(1) 
  + (- (sin x)) d(0) d(2) 
  + (- (sin x)) d(1) d(2) 
  + (cos x) d(0) + (cos x) d(1) 
  + (cos x) d(2) 
  + (sin x)

\end{code}

As stated before, tensor-of-duals approach blows the number of terms exponentially.
Let's see how higher infinitesimal works.

\begin{code}
eps :: Floating a => Weil (DOrder 4) a
eps = di 0
\end{code}

Here, \hask{DOrder n} corresponds to an ideal $\R[X]/(X^n)$.
Note that, according to \Cref{lem:higher-infinitesimal}, to calculate $n$-th derivative  we have to use $\R[X]/(X^{n+1})$.

\begin{code}
>>> (  sin (pi/6),    cos (pi/6), 
      -sin (pi/6)/2, -cos (pi/6)/6)
  (0.49999999999999994,
   0.8660254037844387,
   -0.24999999999999997,
   -0.14433756729740646)
  
>>> sin (pi/6 + eps)
-0.14433756729740646 d(0)^3 
  - 0.24999999999999997 d(0)^2 
  + 0.8660254037844387 d(0)
  + 0.49999999999999994

>>> normalise <$> sin (x + eps)
((-1.0) * cos x / 6.0) d(0)^3 
  + ((- (sin x)) / 2.0) d(0)^2
  + (cos x) d(0) + (sin x)
\end{code}

Note that by \Cref{lem:higher-infinitesimal}, each coefficient is not directly a differential coefficient, but divided by $k!$.

Let's see how we can use tensor products of higher infinitesimal ideals can be used to multivariate higher-order partial derivatives.
Suppose we want to calculate partial derivatives of $f(x, y) = e^{2x} \sin y$ up to $(2, 1)$-th.
\begin{code}
>>> f (2 + eps1) (pi/6 + eps2)
94.5667698566742 d(0)^2 d(1)
  + 54.59815003314423 d(0)^2
  + 94.5667698566742 d(0) d(1)
  + 54.59815003314423 d(0)
  + 47.2833849283371 d(1)
  + 27.299075016572115

>>> normalise <$> f (x+eps1) (y+eps2)
(4.0 * exp (2.0 * x) / 2.0 * cos y) d(0)^2 d(1)
  + (4.0 * exp (2.0 * x) / 2.0 * sin y) d(0)^2
  + (2.0 * exp (2.0 * x) * cos y) d(0) d(1)
  + (2.0 * exp (2.0 * x) * sin y) d(0)
  + (exp (2.0 * x) * cos y) d(1)
  + (exp (2.0 * x) * sin y)
\end{code}

In this way, we can freely compose multiple Weil algebra to calculate various partial derivatives modularly.

\subsection{Computation in General Weil Algebra}
All examples so far is concerning the predefined, specific form of Weil algebra.
Here, we demonstrate that we can determine whether the given ideal defines Weil algebras with \Cref{alg:weil-test}, and some actual calculation in arbitrary Weil algebra.

First, we see that \textsc{WeilTest} rejects invalid ideals:

\begin{code}
-- R[X,Y]/(X^2 - Y), not zero-dimensional
>>> isWeil (toIdeal [x ^3 - y :: Q[x,y]])
Nothing

-- R[X]/(X^2 - 1), which is zero-dimensional but not Weil
>>> isWeil (toIdeal [x - 1 :: Q[x]])
Nothing
\end{code}

Next, we try to calculate in arbitrary chosen Weil algebra, $W = \R[x,y]/(x^2 - y^3, y^4)$, whose corresponding meaning in AD is unclear but is a Weil algebra as a matter of fact.

\begin{code}
i :: Ideal (Rational[x,y])
i = toIdeal [x ^ 2 - y ^ 3, y ^ 4]

>>> isWeil red
Just WeilSettings 
  {weilBasis =
    [[0,0],[0,1],...,[3,0]]
  , nonZeroVarMaxPowers = [3,3]
  , weilMonomDic = 
    [([0,2],[0,0,0,1,0,0,0,0]),
      ...,([1,3],[0,0,0,0,0,0,0,1])]
  , table = [((0,0),1),((1,3),d(0)^2)
      ,...,((3,4),d(0)^3)]
  }
\end{code}

Let's see what will happen evaluating $sin(a + d_0 + d_1)$, where $d_0 = [x]_I, d_1 = [y]_I$?

\begin{code}
>>> withWeil i (sin (pi/4 + di 0 + di 1))
-2.7755575615628914e-17 d(0)^3 
  - ...
  + 0.7071067811865476 d(0)
  + 0.7071067811865476 d(1)
  + 0.7071067811865475

>>> withWeil i (normalise <$> sin (x + di 0 + di 1))
((-1.0) * (- (sin x)) / 6.0 
    + (-1.0) * cos x / 6.0
  ) d(0)^3
  + ...
  + (cos x) d(0)
  + (cos x) d(1) + (sin x)
\end{code}

Carefully analysing each output, one can see that the output coincides with what is given by \Cref{thm:series-is-smooth} and \Cref{lem:quot-ring-ideal}.

\section{Discussions and Conclusions}\label{sec:concl}
We have illustrated the connection of automatic differentiation (AD) and $C^\infty$-rings, especially Weil algebras.
Using tensor products of Weil algebra, one can easily compose (univariate) higher-order AD corresponding to Weil algebras into multivariate ones.
In this last section, we briefly discuss the possible applications aside AD, related works and future works.

\subsection{Possible Applications and Related Works}
Beside the reformulation of AD, we can argue that our methods can be used for a pedagogical purpose in teaching \emph{Smooth Infinitesimal Analysis} (SIA) and \emph{Synthetic Differential Geometry} (SDG).
In those fields, arguing in the appropriate intuitionistic topos, various infinitesimal spaces corresponding to Weil algebra is used to build a theory, expressed by the following \emph{generalised Kock-Lawvere axiom}~\cite{Moerdijk:1991aa}:

\begin{quote}
  For any Weil algebra $W$, the following evaluation map gives an isomorphism:
  \begin{align*}
    f: &W \to   \R^{\mathop{\mathrm{Spec}}_\R{W}}\\
       &a \mapsto \lambda f. f(a)
  \end{align*}
\end{quote}
This is another way to state the fact that Weil algebras are $C^\infty$-rings, viewed within some topoi.
For dual numbers, their meaning is clear: it just couples a value and their (first-order) differential coefficient.
But, solely from Kock-Lawvere axiom, it is unclear what the result corresponding to general Weil algebra $W$.
With the algorithms we have presented, students can use computers to calculate what the map given by the axiom actually is.
Since, in these fields, there are plenty of uses of generalised infinitesimal spaces such as $\R[x_1,\dots, x_n]/\braket{x_i x_j | i, j \leq n}$ or $\R[x]/(x^n)$,concrete examples for these Weil algebras can help to understand the theory.

In the context of SDG, applying techniques in computer algebra to Weil algebras has attained only little interest.
One such example is Nishimura--Osoekawa~\cite{Nishimura:2007aa}: they apply zero-dimensional ideal algorithms to compute categorical limits of Weil algebras.
However, their purpose is to use computer algebra to ease heavy calculations needed to develop the theory of SDG, and hence they are not interested in computing $C^\infty$-structure of Weil algebras, but calculating the finite presentation of limits of diagrams of Weil algebras.

Implementing AD in a functional setting has a long history.
See, for example, Elliott~\cite{Elliott2009-beautiful-differentiation} for explanation and \texttt{ad} package by Kmett~\cite{Kmett:2010aa} for actual implementation.
In \texttt{ad} package, so-called \emph{Skolem trick}, or \emph{RankN trick} is applied to distinguish multiple directional derivatives.
We argue that, our method pursues other direction of formulations; we treat higher infinitesimals as first-class citizens, enabling us to express and compose higher-order ADs in a more modular and composable manner.

\subsection{Future Works}
In SDG, $C^\infty$-ring and higher infinitesimals are used as fundamental building blocks to formulate manifolds, vector fields, differential forms, and so on.
Hence, if one can extend our method to treat general $C^\infty$-algebra $C^\infty(M)$ of real-valued smooth functions on $M$, it can open up a new door to formulate differential geometry on computer.
One major obstacle in this direction is that, even if $C^\infty(M)$ is finitely \emph{presented} as an $C^\infty$-ring, it is NOT finitely \emph{generated} as an $\R$-algebra, but $2^{\aleph_0}$-generated, by its very nature.
Hence, computing $C^\infty(M)$ purely symbolically and directly seems impossible; we need some workarounds or distinct formulations to overcome such obstacles.

As for connections with AD, there are also many rooms for further research.
There are so many ``modes'' other than Forward-mode in AD: for examples, Reverse, Mixed, Sparse, Tower, etc.\ amongst others.
We can study the connection with other modes of ADs and Weil algebra, and perhaps extend formulation to allow polymorphism in such mods in computing Weil algebra.

\begin{acks}
The author is grateful to Prof.\ Akira Terui, for encouraging  to write this paper.

This work was supported by the Research Institute for Mathematical Sciences,
an International Joint Usage/Research Center located in Kyoto University.
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{../references}

\end{document}
\endinput
